// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GSNET_GSNET_H_
#define FLATBUFFERS_GENERATED_GSNET_GSNET_H_

#include "flatbuffers/flatbuffers.h"

namespace GSNet {

struct CLConnect;

struct GSAcceptConnect;

struct GSRefuseConnect;

struct GSPlayerConnected;

struct CLPlayerReady;

struct GSGenMap;

struct CLGenMapDone;

struct GSGameStart;

struct CLMovement;

struct GSMovement;

struct CLTakeItem;

struct GSTakeItem;

struct CLCheckWin;

struct GSGameEnd;

struct GSSpawnPlayer;

struct GSSpawnItem;

struct GSSpawnConstruction;

struct GSSpawnMonster;

struct GSMoveMonster;

struct CLPlayerEscapeDrown;

struct GSPlayerEscapeDrown;

struct GSPlayerDrown;

struct GSPlayerJoinDuel;

struct GSEvent;

enum Type {
  Type_CL_PING = 0,
  Type_SRV_PING = 1,
  Type_CL_CONNECT = 2,
  Type_SRV_ACCEPT_CONNECT = 3,
  Type_SRV_REFUSE_CONNECT = 4,
  Type_SRV_PLAYER_CONNECTED = 5,
  Type_CL_PLAYER_READY = 6,
  Type_SRV_GEN_MAP = 7,
  Type_CL_GEN_MAP_OK = 8,
  Type_SRV_GAME_START = 9,
  Type_CL_MOVEMENT = 10,
  Type_SRV_MOVEMENT = 11,
  Type_CL_TAKE_EQUIP = 12,
  Type_SRV_TAKE_EQUIP = 13,
  Type_CL_ATTACK_PLAYER = 14,
  Type_SRV_ATTACK_PLAYER = 15,
  Type_CL_ATTACK_MONSTER = 16,
  Type_SRV_ATTACK_MONSTER = 17,
  Type_CL_CHECK_WIN = 18,
  Type_SRV_GAME_END = 19,
  Type_SRV_MONSTER_MOVE = 20,
  Type_SRV_SPAWN_PLAYER = 21,
  Type_SRV_SPAWN_MONSTER = 22,
  Type_SRV_SPAWN_ITEM = 23,
  Type_SRV_SPAWN_CONSTRUCTION = 24,
  Type_MIN = Type_CL_PING,
  Type_MAX = Type_SRV_SPAWN_CONSTRUCTION
};

inline const char **EnumNamesType() {
  static const char *names[] = {
    "CL_PING",
    "SRV_PING",
    "CL_CONNECT",
    "SRV_ACCEPT_CONNECT",
    "SRV_REFUSE_CONNECT",
    "SRV_PLAYER_CONNECTED",
    "CL_PLAYER_READY",
    "SRV_GEN_MAP",
    "CL_GEN_MAP_OK",
    "SRV_GAME_START",
    "CL_MOVEMENT",
    "SRV_MOVEMENT",
    "CL_TAKE_EQUIP",
    "SRV_TAKE_EQUIP",
    "CL_ATTACK_PLAYER",
    "SRV_ATTACK_PLAYER",
    "CL_ATTACK_MONSTER",
    "SRV_ATTACK_MONSTER",
    "CL_CHECK_WIN",
    "SRV_GAME_END",
    "SRV_MONSTER_MOVE",
    "SRV_SPAWN_PLAYER",
    "SRV_SPAWN_MONSTER",
    "SRV_SPAWN_ITEM",
    "SRV_SPAWN_CONSTRUCTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesType()[index];
}

enum GSEvents {
  GSEvents_NONE = 0,
  GSEvents_CLConnect = 1,
  GSEvents_GSAcceptConnect = 2,
  GSEvents_GSRefuseConnect = 3,
  GSEvents_GSPlayerConnected = 4,
  GSEvents_CLPlayerReady = 5,
  GSEvents_GSGenMap = 6,
  GSEvents_CLGenMapDone = 7,
  GSEvents_GSGameStart = 8,
  GSEvents_CLMovement = 9,
  GSEvents_GSMovement = 10,
  GSEvents_CLTakeItem = 11,
  GSEvents_GSTakeItem = 12,
  GSEvents_CLCheckWin = 13,
  GSEvents_GSGameEnd = 14,
  GSEvents_GSPlayerDrown = 15,
  GSEvents_CLPlayerEscapeDrown = 16,
  GSEvents_GSPlayerEscapeDrown = 17,
  GSEvents_GSPlayerJoinDuel = 18,
  GSEvents_GSSpawnPlayer = 19,
  GSEvents_GSSpawnItem = 20,
  GSEvents_GSSpawnConstruction = 21,
  GSEvents_GSSpawnMonster = 22,
  GSEvents_GSMoveMonster = 23,
  GSEvents_MIN = GSEvents_NONE,
  GSEvents_MAX = GSEvents_GSMoveMonster
};

inline const char **EnumNamesGSEvents() {
  static const char *names[] = {
    "NONE",
    "CLConnect",
    "GSAcceptConnect",
    "GSRefuseConnect",
    "GSPlayerConnected",
    "CLPlayerReady",
    "GSGenMap",
    "CLGenMapDone",
    "GSGameStart",
    "CLMovement",
    "GSMovement",
    "CLTakeItem",
    "GSTakeItem",
    "CLCheckWin",
    "GSGameEnd",
    "GSPlayerDrown",
    "CLPlayerEscapeDrown",
    "GSPlayerEscapeDrown",
    "GSPlayerJoinDuel",
    "GSSpawnPlayer",
    "GSSpawnItem",
    "GSSpawnConstruction",
    "GSSpawnMonster",
    "GSMoveMonster",
    nullptr
  };
  return names;
}

inline const char *EnumNameGSEvents(GSEvents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGSEvents()[index];
}

template<typename T> struct GSEventsTraits {
  static const GSEvents enum_value = GSEvents_NONE;
};

template<> struct GSEventsTraits<CLConnect> {
  static const GSEvents enum_value = GSEvents_CLConnect;
};

template<> struct GSEventsTraits<GSAcceptConnect> {
  static const GSEvents enum_value = GSEvents_GSAcceptConnect;
};

template<> struct GSEventsTraits<GSRefuseConnect> {
  static const GSEvents enum_value = GSEvents_GSRefuseConnect;
};

template<> struct GSEventsTraits<GSPlayerConnected> {
  static const GSEvents enum_value = GSEvents_GSPlayerConnected;
};

template<> struct GSEventsTraits<CLPlayerReady> {
  static const GSEvents enum_value = GSEvents_CLPlayerReady;
};

template<> struct GSEventsTraits<GSGenMap> {
  static const GSEvents enum_value = GSEvents_GSGenMap;
};

template<> struct GSEventsTraits<CLGenMapDone> {
  static const GSEvents enum_value = GSEvents_CLGenMapDone;
};

template<> struct GSEventsTraits<GSGameStart> {
  static const GSEvents enum_value = GSEvents_GSGameStart;
};

template<> struct GSEventsTraits<CLMovement> {
  static const GSEvents enum_value = GSEvents_CLMovement;
};

template<> struct GSEventsTraits<GSMovement> {
  static const GSEvents enum_value = GSEvents_GSMovement;
};

template<> struct GSEventsTraits<CLTakeItem> {
  static const GSEvents enum_value = GSEvents_CLTakeItem;
};

template<> struct GSEventsTraits<GSTakeItem> {
  static const GSEvents enum_value = GSEvents_GSTakeItem;
};

template<> struct GSEventsTraits<CLCheckWin> {
  static const GSEvents enum_value = GSEvents_CLCheckWin;
};

template<> struct GSEventsTraits<GSGameEnd> {
  static const GSEvents enum_value = GSEvents_GSGameEnd;
};

template<> struct GSEventsTraits<GSPlayerDrown> {
  static const GSEvents enum_value = GSEvents_GSPlayerDrown;
};

template<> struct GSEventsTraits<CLPlayerEscapeDrown> {
  static const GSEvents enum_value = GSEvents_CLPlayerEscapeDrown;
};

template<> struct GSEventsTraits<GSPlayerEscapeDrown> {
  static const GSEvents enum_value = GSEvents_GSPlayerEscapeDrown;
};

template<> struct GSEventsTraits<GSPlayerJoinDuel> {
  static const GSEvents enum_value = GSEvents_GSPlayerJoinDuel;
};

template<> struct GSEventsTraits<GSSpawnPlayer> {
  static const GSEvents enum_value = GSEvents_GSSpawnPlayer;
};

template<> struct GSEventsTraits<GSSpawnItem> {
  static const GSEvents enum_value = GSEvents_GSSpawnItem;
};

template<> struct GSEventsTraits<GSSpawnConstruction> {
  static const GSEvents enum_value = GSEvents_GSSpawnConstruction;
};

template<> struct GSEventsTraits<GSSpawnMonster> {
  static const GSEvents enum_value = GSEvents_GSSpawnMonster;
};

template<> struct GSEventsTraits<GSMoveMonster> {
  static const GSEvents enum_value = GSEvents_GSMoveMonster;
};

bool VerifyGSEvents(flatbuffers::Verifier &verifier, const void *obj, GSEvents type);
bool VerifyGSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CLConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_NICKNAME = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
           verifier.Verify(nickname()) &&
           verifier.EndTable();
  }
};

struct CLConnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLConnect::VT_PLAYER_UID, player_uid, 0);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(CLConnect::VT_NICKNAME, nickname);
  }
  CLConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLConnectBuilder &operator=(const CLConnectBuilder &);
  flatbuffers::Offset<CLConnect> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLConnect> CreateCLConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0) {
  CLConnectBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLConnect> CreateCLConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    const char *nickname = nullptr) {
  return CreateCLConnect(
      _fbb,
      player_uid,
      nickname ? _fbb.CreateString(nickname) : 0);
}

struct GSAcceptConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct GSAcceptConnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSAcceptConnect::VT_PLAYER_UID, player_uid, 0);
  }
  GSAcceptConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSAcceptConnectBuilder &operator=(const GSAcceptConnectBuilder &);
  flatbuffers::Offset<GSAcceptConnect> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<GSAcceptConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSAcceptConnect> CreateGSAcceptConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  GSAcceptConnectBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSRefuseConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct GSRefuseConnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSRefuseConnect::VT_PLAYER_UID, player_uid, 0);
  }
  GSRefuseConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSRefuseConnectBuilder &operator=(const GSRefuseConnectBuilder &);
  flatbuffers::Offset<GSRefuseConnect> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<GSRefuseConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSRefuseConnect> CreateGSRefuseConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  GSRefuseConnectBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSPlayerConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_NICKNAME = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
           verifier.Verify(nickname()) &&
           verifier.EndTable();
  }
};

struct GSPlayerConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSPlayerConnected::VT_PLAYER_UID, player_uid, 0);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(GSPlayerConnected::VT_NICKNAME, nickname);
  }
  GSPlayerConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSPlayerConnectedBuilder &operator=(const GSPlayerConnectedBuilder &);
  flatbuffers::Offset<GSPlayerConnected> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GSPlayerConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSPlayerConnected> CreateGSPlayerConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0) {
  GSPlayerConnectedBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<GSPlayerConnected> CreateGSPlayerConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    const char *nickname = nullptr) {
  return CreateGSPlayerConnected(
      _fbb,
      player_uid,
      nickname ? _fbb.CreateString(nickname) : 0);
}

struct CLPlayerReady FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLPlayerReadyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLPlayerReady::VT_PLAYER_UID, player_uid, 0);
  }
  CLPlayerReadyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLPlayerReadyBuilder &operator=(const CLPlayerReadyBuilder &);
  flatbuffers::Offset<CLPlayerReady> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLPlayerReady>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLPlayerReady> CreateCLPlayerReady(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLPlayerReadyBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSGenMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHUNKN = 4,
    VT_SEED = 6
  };
  uint16_t chunkn() const {
    return GetField<uint16_t>(VT_CHUNKN, 0);
  }
  uint32_t seed() const {
    return GetField<uint32_t>(VT_SEED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CHUNKN) &&
           VerifyField<uint32_t>(verifier, VT_SEED) &&
           verifier.EndTable();
  }
};

struct GSGenMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunkn(uint16_t chunkn) {
    fbb_.AddElement<uint16_t>(GSGenMap::VT_CHUNKN, chunkn, 0);
  }
  void add_seed(uint32_t seed) {
    fbb_.AddElement<uint32_t>(GSGenMap::VT_SEED, seed, 0);
  }
  GSGenMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSGenMapBuilder &operator=(const GSGenMapBuilder &);
  flatbuffers::Offset<GSGenMap> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GSGenMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSGenMap> CreateGSGenMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t chunkn = 0,
    uint32_t seed = 0) {
  GSGenMapBuilder builder_(_fbb);
  builder_.add_seed(seed);
  builder_.add_chunkn(chunkn);
  return builder_.Finish();
}

struct CLGenMapDone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLGenMapDoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLGenMapDone::VT_PLAYER_UID, player_uid, 0);
  }
  CLGenMapDoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLGenMapDoneBuilder &operator=(const CLGenMapDoneBuilder &);
  flatbuffers::Offset<CLGenMapDone> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLGenMapDone>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLGenMapDone> CreateCLGenMapDone(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLGenMapDoneBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSGameStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GSGameStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  GSGameStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSGameStartBuilder &operator=(const GSGameStartBuilder &);
  flatbuffers::Offset<GSGameStart> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<GSGameStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSGameStart> CreateGSGameStart(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GSGameStartBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLMovement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct CLMovementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLMovement::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(CLMovement::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(CLMovement::VT_Y, y, 0);
  }
  CLMovementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLMovementBuilder &operator=(const CLMovementBuilder &);
  flatbuffers::Offset<CLMovement> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CLMovement>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLMovement> CreateCLMovement(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  CLMovementBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct GSMovement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct GSMovementBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSMovement::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(GSMovement::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(GSMovement::VT_Y, y, 0);
  }
  GSMovementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSMovementBuilder &operator=(const GSMovementBuilder &);
  flatbuffers::Offset<GSMovement> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<GSMovement>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSMovement> CreateGSMovement(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  GSMovementBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct CLTakeItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ITEM_UID = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           verifier.EndTable();
  }
};

struct CLTakeItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLTakeItem::VT_PLAYER_UID, player_uid, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(CLTakeItem::VT_ITEM_UID, item_uid, 0);
  }
  CLTakeItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLTakeItemBuilder &operator=(const CLTakeItemBuilder &);
  flatbuffers::Offset<CLTakeItem> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLTakeItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLTakeItem> CreateCLTakeItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t item_uid = 0) {
  CLTakeItemBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_item_uid(item_uid);
  return builder_.Finish();
}

struct GSTakeItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ITEM_UID = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           verifier.EndTable();
  }
};

struct GSTakeItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSTakeItem::VT_PLAYER_UID, player_uid, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(GSTakeItem::VT_ITEM_UID, item_uid, 0);
  }
  GSTakeItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSTakeItemBuilder &operator=(const GSTakeItemBuilder &);
  flatbuffers::Offset<GSTakeItem> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GSTakeItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSTakeItem> CreateGSTakeItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t item_uid = 0) {
  GSTakeItemBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_item_uid(item_uid);
  return builder_.Finish();
}

struct CLCheckWin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLCheckWinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLCheckWin::VT_PLAYER_UID, player_uid, 0);
  }
  CLCheckWinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLCheckWinBuilder &operator=(const CLCheckWinBuilder &);
  flatbuffers::Offset<CLCheckWin> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLCheckWin>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLCheckWin> CreateCLCheckWin(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLCheckWinBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSGameEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct GSGameEndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSGameEnd::VT_PLAYER_UID, player_uid, 0);
  }
  GSGameEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSGameEndBuilder &operator=(const GSGameEndBuilder &);
  flatbuffers::Offset<GSGameEnd> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<GSGameEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSGameEnd> CreateGSGameEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  GSGameEndBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSSpawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct GSSpawnPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSSpawnPlayer::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(GSSpawnPlayer::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(GSSpawnPlayer::VT_Y, y, 0);
  }
  GSSpawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSSpawnPlayerBuilder &operator=(const GSSpawnPlayerBuilder &);
  flatbuffers::Offset<GSSpawnPlayer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<GSSpawnPlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSSpawnPlayer> CreateGSSpawnPlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  GSSpawnPlayerBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct GSSpawnItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEM_TYPE = 4,
    VT_ITEM_UID = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint8_t item_type() const {
    return GetField<uint8_t>(VT_ITEM_TYPE, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ITEM_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct GSSpawnItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_type(uint8_t item_type) {
    fbb_.AddElement<uint8_t>(GSSpawnItem::VT_ITEM_TYPE, item_type, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(GSSpawnItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(GSSpawnItem::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(GSSpawnItem::VT_Y, y, 0);
  }
  GSSpawnItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSSpawnItemBuilder &operator=(const GSSpawnItemBuilder &);
  flatbuffers::Offset<GSSpawnItem> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<GSSpawnItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSSpawnItem> CreateGSSpawnItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t item_type = 0,
    uint16_t item_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  GSSpawnItemBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_item_uid(item_uid);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct GSSpawnConstruction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONSTR_TYPE = 4,
    VT_CONSTR_UID = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint8_t constr_type() const {
    return GetField<uint8_t>(VT_CONSTR_TYPE, 0);
  }
  uint16_t constr_uid() const {
    return GetField<uint16_t>(VT_CONSTR_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONSTR_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_CONSTR_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct GSSpawnConstructionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constr_type(uint8_t constr_type) {
    fbb_.AddElement<uint8_t>(GSSpawnConstruction::VT_CONSTR_TYPE, constr_type, 0);
  }
  void add_constr_uid(uint16_t constr_uid) {
    fbb_.AddElement<uint16_t>(GSSpawnConstruction::VT_CONSTR_UID, constr_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(GSSpawnConstruction::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(GSSpawnConstruction::VT_Y, y, 0);
  }
  GSSpawnConstructionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSSpawnConstructionBuilder &operator=(const GSSpawnConstructionBuilder &);
  flatbuffers::Offset<GSSpawnConstruction> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<GSSpawnConstruction>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSSpawnConstruction> CreateGSSpawnConstruction(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t constr_type = 0,
    uint16_t constr_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  GSSpawnConstructionBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_constr_uid(constr_uid);
  builder_.add_constr_type(constr_type);
  return builder_.Finish();
}

struct GSSpawnMonster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MONSTER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint16_t monster_uid() const {
    return GetField<uint16_t>(VT_MONSTER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MONSTER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct GSSpawnMonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_monster_uid(uint16_t monster_uid) {
    fbb_.AddElement<uint16_t>(GSSpawnMonster::VT_MONSTER_UID, monster_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(GSSpawnMonster::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(GSSpawnMonster::VT_Y, y, 0);
  }
  GSSpawnMonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSSpawnMonsterBuilder &operator=(const GSSpawnMonsterBuilder &);
  flatbuffers::Offset<GSSpawnMonster> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<GSSpawnMonster>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSSpawnMonster> CreateGSSpawnMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t monster_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  GSSpawnMonsterBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_monster_uid(monster_uid);
  return builder_.Finish();
}

struct GSMoveMonster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MONSTER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint16_t monster_uid() const {
    return GetField<uint16_t>(VT_MONSTER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MONSTER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct GSMoveMonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_monster_uid(uint16_t monster_uid) {
    fbb_.AddElement<uint16_t>(GSMoveMonster::VT_MONSTER_UID, monster_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(GSMoveMonster::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(GSMoveMonster::VT_Y, y, 0);
  }
  GSMoveMonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSMoveMonsterBuilder &operator=(const GSMoveMonsterBuilder &);
  flatbuffers::Offset<GSMoveMonster> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<GSMoveMonster>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSMoveMonster> CreateGSMoveMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t monster_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  GSMoveMonsterBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_monster_uid(monster_uid);
  return builder_.Finish();
}

struct CLPlayerEscapeDrown FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLPlayerEscapeDrownBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLPlayerEscapeDrown::VT_PLAYER_UID, player_uid, 0);
  }
  CLPlayerEscapeDrownBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLPlayerEscapeDrownBuilder &operator=(const CLPlayerEscapeDrownBuilder &);
  flatbuffers::Offset<CLPlayerEscapeDrown> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLPlayerEscapeDrown>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLPlayerEscapeDrown> CreateCLPlayerEscapeDrown(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLPlayerEscapeDrownBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSPlayerEscapeDrown FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct GSPlayerEscapeDrownBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSPlayerEscapeDrown::VT_PLAYER_UID, player_uid, 0);
  }
  GSPlayerEscapeDrownBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSPlayerEscapeDrownBuilder &operator=(const GSPlayerEscapeDrownBuilder &);
  flatbuffers::Offset<GSPlayerEscapeDrown> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<GSPlayerEscapeDrown>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSPlayerEscapeDrown> CreateGSPlayerEscapeDrown(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  GSPlayerEscapeDrownBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSPlayerDrown FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct GSPlayerDrownBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSPlayerDrown::VT_PLAYER_UID, player_uid, 0);
  }
  GSPlayerDrownBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSPlayerDrownBuilder &operator=(const GSPlayerDrownBuilder &);
  flatbuffers::Offset<GSPlayerDrown> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<GSPlayerDrown>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSPlayerDrown> CreateGSPlayerDrown(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  GSPlayerDrownBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSPlayerJoinDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_DUEL_PLAYER_UID = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint32_t duel_player_uid() const {
    return GetField<uint32_t>(VT_DUEL_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint32_t>(verifier, VT_DUEL_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct GSPlayerJoinDuelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(GSPlayerJoinDuel::VT_PLAYER_UID, player_uid, 0);
  }
  void add_duel_player_uid(uint32_t duel_player_uid) {
    fbb_.AddElement<uint32_t>(GSPlayerJoinDuel::VT_DUEL_PLAYER_UID, duel_player_uid, 0);
  }
  GSPlayerJoinDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSPlayerJoinDuelBuilder &operator=(const GSPlayerJoinDuelBuilder &);
  flatbuffers::Offset<GSPlayerJoinDuel> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GSPlayerJoinDuel>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSPlayerJoinDuel> CreateGSPlayerJoinDuel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint32_t duel_player_uid = 0) {
  GSPlayerJoinDuelBuilder builder_(_fbb);
  builder_.add_duel_player_uid(duel_player_uid);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct GSEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  GSEvents event_type() const {
    return static_cast<GSEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
           VerifyGSEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

struct GSEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(GSEvents event_type) {
    fbb_.AddElement<uint8_t>(GSEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(GSEvent::VT_EVENT, event);
  }
  GSEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSEventBuilder &operator=(const GSEventBuilder &);
  flatbuffers::Offset<GSEvent> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GSEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSEvent> CreateGSEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    GSEvents event_type = GSEvents_NONE,
    flatbuffers::Offset<void> event = 0) {
  GSEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyGSEvents(flatbuffers::Verifier &verifier, const void *obj, GSEvents type) {
  switch (type) {
    case GSEvents_NONE: {
      return true;
    }
    case GSEvents_CLConnect: {
      auto ptr = reinterpret_cast<const CLConnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSAcceptConnect: {
      auto ptr = reinterpret_cast<const GSAcceptConnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSRefuseConnect: {
      auto ptr = reinterpret_cast<const GSRefuseConnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSPlayerConnected: {
      auto ptr = reinterpret_cast<const GSPlayerConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_CLPlayerReady: {
      auto ptr = reinterpret_cast<const CLPlayerReady *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSGenMap: {
      auto ptr = reinterpret_cast<const GSGenMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_CLGenMapDone: {
      auto ptr = reinterpret_cast<const CLGenMapDone *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSGameStart: {
      auto ptr = reinterpret_cast<const GSGameStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_CLMovement: {
      auto ptr = reinterpret_cast<const CLMovement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSMovement: {
      auto ptr = reinterpret_cast<const GSMovement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_CLTakeItem: {
      auto ptr = reinterpret_cast<const CLTakeItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSTakeItem: {
      auto ptr = reinterpret_cast<const GSTakeItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_CLCheckWin: {
      auto ptr = reinterpret_cast<const CLCheckWin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSGameEnd: {
      auto ptr = reinterpret_cast<const GSGameEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSPlayerDrown: {
      auto ptr = reinterpret_cast<const GSPlayerDrown *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_CLPlayerEscapeDrown: {
      auto ptr = reinterpret_cast<const CLPlayerEscapeDrown *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSPlayerEscapeDrown: {
      auto ptr = reinterpret_cast<const GSPlayerEscapeDrown *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSPlayerJoinDuel: {
      auto ptr = reinterpret_cast<const GSPlayerJoinDuel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSSpawnPlayer: {
      auto ptr = reinterpret_cast<const GSSpawnPlayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSSpawnItem: {
      auto ptr = reinterpret_cast<const GSSpawnItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSSpawnConstruction: {
      auto ptr = reinterpret_cast<const GSSpawnConstruction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSSpawnMonster: {
      auto ptr = reinterpret_cast<const GSSpawnMonster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GSEvents_GSMoveMonster: {
      auto ptr = reinterpret_cast<const GSMoveMonster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyGSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGSEvents(
        verifier,  values->Get(i), types->GetEnum<GSEvents>(i))) {
      return false;
    }
  }
  return true;
}

inline const GSNet::GSEvent *GetGSEvent(const void *buf) {
  return flatbuffers::GetRoot<GSNet::GSEvent>(buf);
}

inline bool VerifyGSEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GSNet::GSEvent>(nullptr);
}

inline void FinishGSEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GSNet::GSEvent> root) {
  fbb.Finish(root);
}

}  // namespace GSNet

#endif  // FLATBUFFERS_GENERATED_GSNET_GSNET_H_
